<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Strongly Typed Ids in Entity Framework Core (2/N) | macrobert.com</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Strongly Typed Ids in Entity Framework Core (2/N)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This article is a continuation of a previous article exploring the use of Strongly Typed Ids in .NET Entity Framework Core." />
<meta property="og:description" content="This article is a continuation of a previous article exploring the use of Strongly Typed Ids in .NET Entity Framework Core." />
<link rel="canonical" href="https://blog.macrobert.com/dotnet/strongly_typed_ids/efcore/2023/07/03/StronglyTypedIds_In_EF_Core.html" />
<meta property="og:url" content="https://blog.macrobert.com/dotnet/strongly_typed_ids/efcore/2023/07/03/StronglyTypedIds_In_EF_Core.html" />
<meta property="og:site_name" content="macrobert.com" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-07-03T12:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Strongly Typed Ids in Entity Framework Core (2/N)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-07-03T12:00:00+08:00","datePublished":"2023-07-03T12:00:00+08:00","description":"This article is a continuation of a previous article exploring the use of Strongly Typed Ids in .NET Entity Framework Core.","headline":"Strongly Typed Ids in Entity Framework Core (2/N)","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.macrobert.com/dotnet/strongly_typed_ids/efcore/2023/07/03/StronglyTypedIds_In_EF_Core.html"},"url":"https://blog.macrobert.com/dotnet/strongly_typed_ids/efcore/2023/07/03/StronglyTypedIds_In_EF_Core.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://blog.macrobert.com/feed.xml" title="macrobert.com" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">macrobert.com</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Strongly Typed Ids in Entity Framework Core (2/N)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-07-03T12:00:00+08:00" itemprop="datePublished">Jul 3, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>This article is a continuation of a <a href="/dotnet/strongly_typed_ids/2023/06/30/StronglyTypedIds.html">previous article</a> exploring the use of Strongly Typed Ids in .NET Entity Framework Core.</p>

<p>In this article we’ll explore how to fully intgrate Strongly Typed Ids into an EF Core application. We’ll intentionally work through a non-trivial solution to ensure that issues like code-maintainability and scalability are also addressed so that 
the EF Core framework treats Strongly Typed Ids as first class citizens in an application, transparently converting and persisting data, where a developer merely has to declare the existence of a type.</p>

<p>When developing applications with Entity Framework Core (EF Core), the usage of primary keys is a common practice, especially when defining your model entities. Often, these keys are simple types like <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, or <code class="language-plaintext highlighter-rouge">Guid</code>. However, there is another approach that can provide more clarity and safety to your code: Strongly Typed IDs.</p>

<p>A Strongly Typed ID is a wrapper around a simple value, such as an integer or a GUID, that gives it a specific meaning. For example, instead of having a method like <code class="language-plaintext highlighter-rouge">GetOrder(int orderId)</code>, you would have <code class="language-plaintext highlighter-rouge">GetOrder(OrderId orderId)</code>, where <code class="language-plaintext highlighter-rouge">OrderId</code> is a struct or a record that encapsulates the integer ID.</p>

<p>Strongly Typed IDs can bring several advantages to your code:</p>

<ul>
  <li><strong>Improved Readability</strong>: When you see a method signature like <code class="language-plaintext highlighter-rouge">GetOrder(OrderId orderId)</code>, it’s immediately clear what kind of ID the method expects.</li>
  <li><strong>Reduced Errors</strong>: With Strongly Typed IDs, you can’t accidentally pass an <code class="language-plaintext highlighter-rouge">int</code> intended for one kind of entity to a method that expects an <code class="language-plaintext highlighter-rouge">int</code> for a different kind of entity.</li>
  <li><strong>Better Abstraction</strong>: Each ID type can have its own methods and validation rules, encapsulating more behavior and making your code more Object-Oriented.</li>
</ul>

<h2 id="considerations-when-using-strongly-typed-ids-with-entity-framework-core">Considerations when using Strongly Typed IDs with Entity Framework Core</h2>

<p>When using EF Core, you need to consider how the framework will interact with your Strongly Typed IDs. Here are some things to keep in mind:</p>

<ul>
  <li><strong>Mapping to Database Columns</strong>: EF Core needs to know how to map your Strongly Typed ID to a database column. You’ll commonly use the Fluent API in your <code class="language-plaintext highlighter-rouge">DbContext</code> to configure this.</li>
</ul>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span>
    <span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">HasConversion</span><span class="p">(</span>
        <span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span> 
        <span class="n">id</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">OrderId</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>
</code></pre></div></div>

<ul>
  <li><strong>Equality Comparison</strong>: EF Core keeps track of entities based on their IDs. If not using a <code class="language-plaintext highlighter-rouge">record</code> type be sure your Strongly Typed ID implements <code class="language-plaintext highlighter-rouge">Equals</code> and <code class="language-plaintext highlighter-rouge">GetHashCode</code> correctly.</li>
  <li><strong>Performance</strong>: EF Core can track changes to entities based on their IDs. If your ID type has a heavy <code class="language-plaintext highlighter-rouge">Equals</code> or <code class="language-plaintext highlighter-rouge">GetHashCode</code> method, this could impact performance.</li>
  <li><strong>Maintainability</strong>: When adding a <code class="language-plaintext highlighter-rouge">HasConversion</code> implementation everywhere such an Id is used a codebase could become very tedious and hard to maintain.</li>
</ul>

<p>Note in the example above that a <code class="language-plaintext highlighter-rouge">HasConversion</code> implementation will need to be provided for every use of the <code class="language-plaintext highlighter-rouge">OrderId</code> throughout the various entity configurations. We’ll explore a better way for this integration.</p>

<p>If we choose to use Strongly Typed Ids we’d want to integrate the use of Strongly Typed Ids throughout our codebase so as to be as transparent and seamless as possible to minimise the development burden, while being aware of performance considerations.</p>

<p>We’d need:</p>
<ol>
  <li>every Strongly Typed Id to be discoverable. This is typically done via the use of an <code class="language-plaintext highlighter-rouge">Attribute</code> or interface declaration.</li>
  <li>the framework to discover each new Strongly Typed Id declaration based on the mechanism chosen above.</li>
  <li>to register a <strong>re-usable EF Core conversion</strong> so that the object can be persisted to-and-from a database wherever the type is encountered.</li>
</ol>

<p>We can explore how to do this with a non-trivial example.</p>

<h2 id="discoverability">Discoverability</h2>

<p>For our purposes we’ll use an interface approach to permit discovery via .NET Reflection of our Strongly Typed Id declarations.</p>

<p><strong>Example:</strong>
If we declare an interface <code class="language-plaintext highlighter-rouge">IStronglyTypedId</code> and express it generically we can use the interface as broadly as possible.</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To keep things interesting we’ll make our Strongly Typed Ids use a <code class="language-plaintext highlighter-rouge">Ulid</code> value as the underlying value primitive. We’ll also use the ‘Value’ term as property used to extract the underlying primitive value.
For more information on ULIDs <a href="/dotnet/2023/06/28/ULIDs.html">refer to this post</a></p>

<p>Continuing our example therefore we can declare a <code class="language-plaintext highlighter-rouge">CompanyId</code> for use in a <code class="language-plaintext highlighter-rouge">Company</code> entity as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">record</span> <span class="nc">CompanyId</span><span class="p">(</span><span class="n">Ulid</span> <span class="n">Value</span><span class="p">)</span> <span class="p">:</span> <span class="n">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">&gt;;</span>
</code></pre></div></div>
<p>Given the declaration above we can now discover our Strongly Typed Id by scanning for implementations of <code class="language-plaintext highlighter-rouge">IStronglyTypedId&lt;Ulid&gt;</code>.</p>

<p>In a Domain Driven Design context, the <code class="language-plaintext highlighter-rouge">CompanyId</code> helps provide a unique identifier for a <code class="language-plaintext highlighter-rouge">Company </code> Entity so these classes would both be declared in a <code class="language-plaintext highlighter-rouge">Domain</code> project.</p>

<h2 id="framework-discovery-and-registration">Framework Discovery and Registration</h2>

<p>In a non-trivial application we might have 10’s of entity types (or more) and corresponding Id types. It becomes important to ensure that any method to discover this implementation does not rely on any form of manual registration owing to the risks of human error. Any <strong>failure to remember</strong> to modify a ‘registration-class’ will have undesirable consequences.</p>

<p>EF Core 7.0 introduces a new method to the <code class="language-plaintext highlighter-rouge">DBContext</code> which allows us to register new types with the framework:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">protected</span> <span class="k">internal</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">ConfigureConventions</span><span class="p">(</span><span class="n">ModelConfigurationBuilder</span> <span class="n">configurationBuilder</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div>
<p>This is known as <a href="https://aka.ms/efcore-docs-pre-convention">‘Pre-convention configuration’</a>.</p>

<p>By overriding the <code class="language-plaintext highlighter-rouge">ConfigureConventions</code> method we have an opportunity to get our application to discover our collection of Strongly Typed Ids.</p>

<p>For our implementation plan we would need to scan an assembly known to contain our Strongly Typed Ids and obtain the <code class="language-plaintext highlighter-rouge">System.Type</code> of each. We can then iterate through the collection registering each in turn.</p>

<p>To scan an assembly for an interface we might declare a re-usable scanner as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AssemblyScanner</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">Assembly</span> <span class="n">targetAssembly</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">AssemblyScanner</span><span class="p">(</span><span class="n">Assembly</span> <span class="n">targetAssembly</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">targetAssembly</span> <span class="p">=</span> <span class="n">targetAssembly</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">...</span>

    <span class="k">public</span> <span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">&gt;</span> <span class="n">ScanForImplementations</span><span class="p">&lt;</span><span class="n">TInterface</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">&gt;();</span>
        <span class="kt">var</span> <span class="n">targetTypes</span> <span class="p">=</span> <span class="n">targetAssembly</span><span class="p">.</span><span class="nf">GetTypes</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">implementationTypes</span> <span class="p">=</span> <span class="n">targetTypes</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">TInterface</span><span class="p">).</span><span class="nf">IsAssignableFrom</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">t</span><span class="p">.</span><span class="n">IsInterface</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">t</span><span class="p">.</span><span class="n">IsAbstract</span><span class="p">);</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">type</span> <span class="k">in</span> <span class="n">implementationTypes</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
<p>In our <code class="language-plaintext highlighter-rouge">DBContext.ConfigureConventions</code> override we can employ the <code class="language-plaintext highlighter-rouge">AssemblyScanner</code> to search for our <code class="language-plaintext highlighter-rouge">IStronglyTypedId&lt;Ulid&gt;</code> implementations as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">ConfigureConventions</span><span class="p">(</span><span class="n">ModelConfigurationBuilder</span> <span class="n">configurationBuilder</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="kt">var</span> <span class="n">scanner</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AssemblyScanner</span><span class="p">(</span><span class="n">Domain</span><span class="p">.</span><span class="n">AssemblyReference</span><span class="p">.</span><span class="n">Assembly</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">typedIdTypes</span> <span class="p">=</span> <span class="n">scanner</span><span class="p">.</span><span class="n">ScanForImplementations</span><span class="p">&lt;</span><span class="n">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">&gt;&gt;();</span>
    <span class="nf">ConfigureStronglyTypedIds</span><span class="p">(</span><span class="n">typedIdTypes</span><span class="p">);</span>    
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">ConfigureStronglyTypedIds</span><span class="p">(</span><span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">&gt;</span> <span class="n">stronglyTypedIdTypes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">type</span> <span class="k">in</span> <span class="n">stronglyTypedIdTypes</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">configurationBuilder</span>
            <span class="p">.</span><span class="nf">Properties</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
            <span class="p">.</span><span class="nf">HaveMaxLength</span><span class="p">(</span><span class="n">EntityId</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
    <span class="p">}</span>    
<span class="p">}</span>

</code></pre></div></div>
<p>where the <code class="language-plaintext highlighter-rouge">AssemblyReference</code> supplied as a parameter to the <code class="language-plaintext highlighter-rouge">AssemblyScanner</code> is defined as follows:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System.Reflection</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">Domain</span><span class="p">;</span>

<span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">AssemblyReference</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Assembly</span> <span class="n">Assembly</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">AssemblyReference</span><span class="p">).</span><span class="n">Assembly</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>(This technique is popularised by <a href="https://www.youtube.com/@MilanJovanovicTech/featured">Milan Jovanovic</a> in numerous coding examples on his YouTube channel)</p>

<p>We know that <code class="language-plaintext highlighter-rouge">Ulid</code>’s can be expressed as text with 26 characters so <code class="language-plaintext highlighter-rouge">EntityId</code> is defined with a didactic <code class="language-plaintext highlighter-rouge">consts</code> class as:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">EntityId</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">Length</span> <span class="p">=</span> <span class="m">26</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So far our code seems trivial at this point… Except for one problem - we must define the conversion so our DB Provider can persist the data. The body of our loop should read something like:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">configurationBuilder</span>
            <span class="p">.</span><span class="nf">Properties</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
            <span class="p">.</span><span class="nf">HaveConversion</span><span class="p">(...</span><span class="n">What</span> <span class="n">goes</span> <span class="n">here</span><span class="p">?...)</span>
            <span class="p">.</span><span class="nf">HaveMaxLength</span><span class="p">(</span><span class="n">EntityId</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
</code></pre></div></div>
<p>So… what now?</p>

<h2 id="db-provider-value-conversion">DB Provider Value Conversion</h2>

<p>The <code class="language-plaintext highlighter-rouge">HaveConversion</code> FluentAPI demands that we supply some kind of <code class="language-plaintext highlighter-rouge">ValueConverter</code> derived class responsible for converting our Strongly Typed Id to-and-from a DB-Provider-Compatible type. We’re using a <code class="language-plaintext highlighter-rouge">Ulid</code> as our underlying value type which we’ll need to store as a string - at the time of writing <code class="language-plaintext highlighter-rouge">Ulid</code>’s are not widely supported as a Database data type.</p>

<p>We could write a <code class="language-plaintext highlighter-rouge">ValueConverter</code> for every <code class="language-plaintext highlighter-rouge">StronglyTypedId</code> that we define, but this would undermine the benefit of being able to declare a Strongly Typed Id in a single line.</p>

<p>To convert a <code class="language-plaintext highlighter-rouge">Ulid</code> to a <code class="language-plaintext highlighter-rouge">string</code> we can write a simple <code class="language-plaintext highlighter-rouge">ValueConverter</code> as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">Microsoft.EntityFrameworkCore.Storage.ValueConversion</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">UlidToStringConverter</span> <span class="p">:</span> <span class="n">ValueConverter</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">ConverterMappingHints</span> <span class="n">defaultHints</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ConverterMappingHints</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">EntityId</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>

    <span class="k">public</span> <span class="nf">UlidToStringConverter</span><span class="p">(</span><span class="n">ConverterMappingHints</span> <span class="n">mappingHints</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span>
                <span class="n">convertToProviderExpression</span><span class="p">:</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(),</span>
                <span class="n">convertFromProviderExpression</span><span class="p">:</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">Ulid</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="n">mappingHints</span><span class="p">:</span> <span class="n">defaultHints</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="n">mappingHints</span><span class="p">))</span>
    <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is not of much use to us, as it is for our underlying type, not the Strongly Typed Id.</p>

<p>However, based on the example above we could conservatively estimate that we have 10 lines of code per Strongly Typed Id of overhead. So our 40 lines of Strongly Typed Id code now has 400 lines of overhead-code to maintain… Excluding unit-test code. <strong>Not Ideal</strong>. We need to avoid this at all costs as <strong>this approach scales badly</strong>.</p>

<p>We need our framework to <strong>‘automagically’</strong> declare a <code class="language-plaintext highlighter-rouge">ValueConverter</code> for us, as each Strongly Typed Id is discovered.</p>

<p>If we explore further we can we can exploit the power of .NET Generics to create a <code class="language-plaintext highlighter-rouge">ValueConverter</code> to convert to-and-from our Strong Type to a <code class="language-plaintext highlighter-rouge">Ulid</code> as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">StronglyTypedIdToUlidConverter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">ValueConverter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ulid</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">StronglyTypedIdToUlidConverter</span><span class="p">(</span><span class="n">ConverterMappingHints</span><span class="p">?</span> <span class="n">mappingHints</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span>
            <span class="n">convertToProviderExpression</span><span class="p">:</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span>
            <span class="n">convertFromProviderExpression</span><span class="p">:</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">Activator</span><span class="p">.</span><span class="nf">CreateInstance</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[]</span> <span class="p">{</span> <span class="n">x</span> <span class="p">})!,</span>
            <span class="n">mappingHints</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We’re aiming at producing a <code class="language-plaintext highlighter-rouge">StronglyTypedIdToStringConverter</code> that takes a StronglyTypedId generic parameter to convert back and forth between Strongly Typed Ids and strings.</p>

<p>At this point we have x2 implementations that we need to link together. In pseudocode:</p>
<ul>
  <li>Our <code class="language-plaintext highlighter-rouge">convertToProviderExpression</code> must implement <code class="language-plaintext highlighter-rouge">StrongTypeId =&gt; Ulid =&gt; string</code>.</li>
  <li>Our <code class="language-plaintext highlighter-rouge">convertFromProviderExpression</code> must implement <code class="language-plaintext highlighter-rouge">string =&gt; Ulid.Parse(...) =&gt; StrongTypeId</code>.</li>
</ul>

<p>If we express our observations above generically:</p>
<ul>
  <li>We see the <code class="language-plaintext highlighter-rouge">ModelType</code> is our <code class="language-plaintext highlighter-rouge">StrongTypeId</code>.</li>
  <li>We have a <code class="language-plaintext highlighter-rouge">Ulid</code> for an intermediate or <code class="language-plaintext highlighter-rouge">MiddleType</code></li>
  <li>Lastly we have a <code class="language-plaintext highlighter-rouge">string</code> as our <code class="language-plaintext highlighter-rouge">ProviderType</code>.</li>
</ul>

<p>Some extensive spelunking through the EF Core sources revealed a potentially useful <code class="language-plaintext highlighter-rouge">ValueConverter</code> class that allows us to link our implementations above to create what we need:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Microsoft.EntityFrameworkCore.Storage.ValueConversion.Internal</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CompositeValueConverter</span><span class="p">&lt;</span><span class="n">TModel</span><span class="p">,</span> <span class="n">TMiddle</span><span class="p">,</span> <span class="n">TProvider</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">ValueConverter</span><span class="p">&lt;</span><span class="n">TModel</span><span class="p">,</span> <span class="n">TProvider</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">CompositeValueConverter</span><span class="p">(</span><span class="n">ValueConverter</span> <span class="n">converter1</span><span class="p">,</span> <span class="n">ValueConverter</span> <span class="n">converter2</span><span class="p">,</span> <span class="n">ConverterMappingHints</span><span class="p">?</span> <span class="n">mappingHints</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="nf">Compose</span><span class="p">((</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TModel</span><span class="p">,</span> <span class="n">TMiddle</span><span class="p">&gt;&gt;)</span><span class="n">converter1</span><span class="p">.</span><span class="n">ConvertToProviderExpression</span><span class="p">,</span> <span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TMiddle</span><span class="p">,</span> <span class="n">TProvider</span><span class="p">&gt;&gt;)</span><span class="n">converter2</span><span class="p">.</span><span class="n">ConvertToProviderExpression</span><span class="p">),</span> <span class="nf">Compose</span><span class="p">((</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TProvider</span><span class="p">,</span> <span class="n">TMiddle</span><span class="p">&gt;&gt;)</span><span class="n">converter2</span><span class="p">.</span><span class="n">ConvertFromProviderExpression</span><span class="p">,</span> <span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TMiddle</span><span class="p">,</span> <span class="n">TModel</span><span class="p">&gt;&gt;)</span><span class="n">converter1</span><span class="p">.</span><span class="n">ConvertFromProviderExpression</span><span class="p">),</span> <span class="n">mappingHints</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="k">private</span> <span class="k">static</span> <span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;&gt;</span> <span class="n">Compose</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">,</span> <span class="n">TMiddle</span><span class="p">&gt;&gt;</span> <span class="n">upper</span><span class="p">,</span> <span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TMiddle</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;&gt;</span> <span class="n">lower</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;&gt;(</span><span class="n">ReplacingExpressionVisitor</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="n">lower</span><span class="p">.</span><span class="n">Parameters</span><span class="p">.</span><span class="nf">Single</span><span class="p">(),</span> <span class="n">upper</span><span class="p">.</span><span class="n">Body</span><span class="p">,</span> <span class="n">lower</span><span class="p">.</span><span class="n">Body</span><span class="p">),</span> <span class="k">new</span> <span class="n">ParameterExpression</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">{</span> <span class="n">upper</span><span class="p">.</span><span class="n">Parameters</span><span class="p">.</span><span class="nf">Single</span><span class="p">()</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>For the the <code class="language-plaintext highlighter-rouge">CompositeValueConverter</code> snippet above</p>
<ul>
  <li>our <code class="language-plaintext highlighter-rouge">ModelType</code> maps neatly to the <code class="language-plaintext highlighter-rouge">TModel</code> generic parameter (eg. <code class="language-plaintext highlighter-rouge">CompanyId</code>, but could be any Strongly Typed Id).</li>
  <li>our <code class="language-plaintext highlighter-rouge">MiddleType</code> maps to the <code class="language-plaintext highlighter-rouge">TMiddle</code> parameter (ie. <code class="language-plaintext highlighter-rouge">Ulid</code>)</li>
  <li>lastly our <code class="language-plaintext highlighter-rouge">ProviderType</code> maps to the <code class="language-plaintext highlighter-rouge">TProvider</code> generic parameter (ie. <code class="language-plaintext highlighter-rouge">string</code>).</li>
</ul>

<p>It’s pretty clear that by placing this class in an <strong>Internal</strong> namespace the EF Core authors didn’t intend this to be part of the public EF Core API. However it provides a perfect solution to our problem.</p>

<p>We can ‘borrow’ the implementation in our code and re-use our <code class="language-plaintext highlighter-rouge">UlidToStringConverter</code> and  <code class="language-plaintext highlighter-rouge">StronglyTypedIdToUlidConverter&lt;T&gt;</code> implementations and <strong>compose</strong> our generic <code class="language-plaintext highlighter-rouge">ValueConverter</code> as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">StronglyTypedIdToStringConverter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> 
    <span class="p">:</span> <span class="n">CompositeValueConverter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ulid</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">StronglyTypedIdToStringConverter</span><span class="p">()</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span>
            <span class="k">new</span> <span class="n">StronglyTypedIdToUlidConverter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(),</span> 
            <span class="k">new</span> <span class="nf">UlidToStringConverter</span><span class="p">())</span>
    <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’re now much closer to being able to <strong>automagically</strong> create an implementation of a value converter, as we can synthesize a concrete <code class="language-plaintext highlighter-rouge">ValueConverter</code> type by filling in the generic parameter via the Reflection API (as shown):</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">concreteValueConverterType</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">StronglyTypedIdToStringConverter</span><span class="p">&lt;&gt;).</span><span class="nf">MakeGenericType</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
</code></pre></div></div>

<p>Given our <code class="language-plaintext highlighter-rouge">foreach - stronglyTypedIdTypes</code> loop above, we can now automatically register the <code class="language-plaintext highlighter-rouge">ValueConverter</code> for all StronglyTypedIds in our application, including DB Type Mapping. Our <code class="language-plaintext highlighter-rouge">DBContext.ConfigureConventions</code> loop code becomes:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">ConfigureConventions</span><span class="p">(</span><span class="n">ModelConfigurationBuilder</span> <span class="n">configurationBuilder</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="kt">var</span> <span class="n">scanner</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AssemblyScanner</span><span class="p">(</span><span class="n">Domain</span><span class="p">.</span><span class="n">AssemblyReference</span><span class="p">.</span><span class="n">Assembly</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">typedIdTypes</span> <span class="p">=</span> <span class="n">scanner</span><span class="p">.</span><span class="n">ScanForImplementations</span><span class="p">&lt;</span><span class="n">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">&gt;&gt;();</span>
    <span class="nf">ConfigureStronglyTypedIds</span><span class="p">(</span><span class="n">typedIdTypes</span><span class="p">);</span>    
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">ConfigureStronglyTypedIds</span><span class="p">(</span><span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">&gt;</span> <span class="n">stronglyTypedIdTypes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">type</span> <span class="k">in</span> <span class="n">stronglyTypedIdTypes</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">configurationBuilder</span>
            <span class="p">.</span><span class="nf">Properties</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
            <span class="p">.</span><span class="nf">HaveConversion</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">StronglyTypedIdToStringConverter</span><span class="p">&lt;&gt;).</span><span class="nf">MakeGenericType</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>
            <span class="p">.</span><span class="nf">HaveMaxLength</span><span class="p">(</span><span class="n">EntityId</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
    <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div></div>

<p>Returning to our original example for an <code class="language-plaintext highlighter-rouge">Order</code> that might use an <code class="language-plaintext highlighter-rouge">OrderId</code> for it’s Id property… 
The Configuration code becomes:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span>
    <span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</code></pre></div></div>
<p>The EF Core framework is now fully aware of what the <code class="language-plaintext highlighter-rouge">OrderId</code> is and how to interact with the database, so the <code class="language-plaintext highlighter-rouge">HaveConversion</code> code is no longer required as a generic <code class="language-plaintext highlighter-rouge">ValueConverter</code> has already been registered.</p>

<h2 id="summary">Summary</h2>
<p>I’ve demonstrated how we can <strong>automagically</strong> integrate the use of Strongly Typed Ids throughout an EF Core based application.</p>

<p>This includes</p>
<ul>
  <li>the discovery of Strongly Typed Ids throughout an assembly,</li>
  <li>the registration of the types with the EF Core framework</li>
  <li>as well as the automatic implementation of conversions to suit a DB Provider.</li>
</ul>

<p>Casting aside performance considerations, these three implementation details ensure a trouble free and scalable solution to the use of Strongly Typed Ids within an EF Core application.</p>

  </div><a class="u-url" href="/dotnet/strongly_typed_ids/efcore/2023/07/03/StronglyTypedIds_In_EF_Core.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">macrobert.com</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">macrobert.com</li><li><a class="u-email" href="mailto:dev@macrobert.com">dev@macrobert.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/machonky"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">machonky</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Martin lives and works Internationally building really useful things.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
