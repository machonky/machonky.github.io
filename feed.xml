<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://blog.macrobert.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.macrobert.com/" rel="alternate" type="text/html" /><updated>2023-10-26T10:26:58+08:00</updated><id>https://blog.macrobert.com/feed.xml</id><title type="html">macrobert.com</title><subtitle>Martin lives and works Internationally building really useful things.</subtitle><entry><title type="html">Strongly Typed Ids</title><link href="https://blog.macrobert.com/dotnet,/strongly_typed_ids/2023/06/30/StronglyTypedIds.html" rel="alternate" type="text/html" title="Strongly Typed Ids" /><published>2023-06-30T12:00:00+08:00</published><updated>2023-06-30T12:00:00+08:00</updated><id>https://blog.macrobert.com/dotnet,/strongly_typed_ids/2023/06/30/StronglyTypedIds</id><content type="html" xml:base="https://blog.macrobert.com/dotnet,/strongly_typed_ids/2023/06/30/StronglyTypedIds.html"><![CDATA[<p>While studying Domain Driven Design and software architecture, I’ve seen strong advocacy for the use of Strongly-Typed-Ids instead of the traditional use of strings, guids and integers with the aim of preventing ‘Primitive Obsession’ and the ensuing errors associated with this behaviour.</p>

<p>‘Primitive Obsession’ is a term coined by <strong><em>Martin Fowler</em></strong>, a prominent software developer and author. The term is used in software development to describe a scenario where developers use primitive data types to represent domain ideas.</p>

<p><strong><em>Eric Evans</em></strong>, the author of the book <strong><em>“Domain-Driven Design: Tackling Complexity in the Heart of Software”</em></strong>,  is one significant figure in the Domain-Driven Design (DDD) community, which often advocates for practices like strongly-typed IDs. While Evans himself may not explicitly advocate for strongly-typed IDs, the principles he outlines in his book align well with the concept.</p>

<p>Many advocates of statically-typed languages such as C#, Java, or TypeScript also tend to favor strongly-typed IDs. These languages, by their nature, encourage the use of explicit types to improve code clarity and safety.</p>

<p>In the context of EF Core applications, ‘Primitive Obsession’ often refers to using primitive types such as <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">string</code>, or <code class="language-plaintext highlighter-rouge">Guid</code> to represent entity IDs, rather than creating a separate, more specific type. For instance, rather than creating a CustomerId type for customer IDs, a developer might just use an <code class="language-plaintext highlighter-rouge">int</code>. This can lead to confusion as these IDs are passed around the application, as it’s unclear what type of entity the ID refers to.</p>

<p>While using primitive types can be quicker and simpler in the short term, it can lead to problems in the long term, including:</p>

<ul>
  <li><strong>Lack of clarity</strong>: Without a specific type, it’s not immediately clear what an ID refers to. This can make the code harder to understand and maintain.</li>
  <li><strong>Type safety issues</strong>: If you’re using primitive types for IDs, it’s easy to accidentally pass an ID of one type to a method that expects an ID of a different type. The compiler won’t catch this error, and it could lead to bugs that are hard to track down.</li>
  <li><strong>Missed opportunities for encapsulation</strong>: By using a specific type, you can encapsulate logic related to the ID inside that type. For instance, if there are specific rules around what values an ID can have, those rules can be enforced in the ID type itself.</li>
</ul>

<p>To counter this ‘Primitive Obsession’ one should use ‘Domain Primitives’ or ‘Value Objects’. These are small classes that encapsulate a simple domain concept. For example, instead of using an <code class="language-plaintext highlighter-rouge">int</code> for a customer ID, you could create a formal <code class="language-plaintext highlighter-rouge">CustomerId</code> class. This makes the code more self-documenting and helps prevent errors. However, it can increase the complexity of the codebase and requires careful design to ensure the classes are correctly implemented.</p>

<h2 id="lets-look-a-little-closer">Lets look a little closer…</h2>

<p>When building software applications, it’s common to use identifiers (IDs) to uniquely distinguish entities. This is especially true in the realm of databases where IDs are used as primary keys. In .NET’s Entity Framework Core, the default type for these identifiers is often an integer or a GUID. However, there’s a growing trend towards using Strongly-Typed IDs, an approach that has its own set of advantages and limitations.</p>

<h2 id="what-are-strongly-typed-ids">What are Strongly-Typed IDs?</h2>

<p>Traditionally, IDs in Entity Framework Core are represented as simple primitives, like int, long, or Guid. However, these types don’t provide any context or meaning about what they represent. They are just raw values.</p>

<p>Strongly-Typed IDs, on the other hand, wrap these raw values in a more meaningful type. For instance, instead of having an integer represent an OrderID, a new type <code class="language-plaintext highlighter-rouge">OrderId</code> is created. This new type can help to avoid errors and provide clarity about what the ID represents.</p>

<h3 id="example">Example</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">struct</span> <span class="nc">OrderId</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="k">public</span> <span class="nf">OrderId</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In the example above the class name helps express the intent of the class, while being declared as a <code class="language-plaintext highlighter-rouge">struct</code> ensures that equality comparisons are based on their values. If a contained property were to be of a reference type however it would be necessary to override the <code class="language-plaintext highlighter-rouge">Equals</code> method (and <code class="language-plaintext highlighter-rouge">GetHashCode</code> method) in the struct to ensure a proper value comparison.</p>

<p>As of C# 9.0 as part of .NET 5, (released in November 2020), the newer <code class="language-plaintext highlighter-rouge">record</code> type permits a more compact expression of such types as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">record</span> <span class="nc">OrderId</span><span class="p">(</span><span class="kt">int</span> <span class="n">Value</span><span class="p">);</span>
</code></pre></div></div>
<p>The ease of declaration of such types makes it very tempting for use in new projects or retrofitting to older ones.</p>

<p>This being said, it would be wise to identify the full cost of the use of such types in any major project.</p>]]></content><author><name></name></author><category term="dotnet," /><category term="strongly_typed_ids" /><summary type="html"><![CDATA[While studying Domain Driven Design and software architecture, I’ve seen strong advocacy for the use of Strongly-Typed-Ids instead of the traditional use of strings, guids and integers with the aim of preventing ‘Primitive Obsession’ and the ensuing errors associated with this behaviour.]]></summary></entry><entry><title type="html">Comparison: C# `structs` vs `records`</title><link href="https://blog.macrobert.com/dotnet/2023/06/29/structs_vs_records.html" rel="alternate" type="text/html" title="Comparison: C# `structs` vs `records`" /><published>2023-06-29T12:00:00+08:00</published><updated>2023-06-29T12:00:00+08:00</updated><id>https://blog.macrobert.com/dotnet/2023/06/29/structs_vs_records</id><content type="html" xml:base="https://blog.macrobert.com/dotnet/2023/06/29/structs_vs_records.html"><![CDATA[<h1 id="comparison-c-structs-vs-records">Comparison: C# <code class="language-plaintext highlighter-rouge">structs</code> vs <code class="language-plaintext highlighter-rouge">records</code></h1>

<h2 id="structs"><code class="language-plaintext highlighter-rouge">structs</code></h2>

<h3 id="strengths">Strengths:</h3>

<ul>
  <li><strong>Performance</strong>: As value types, structs are stored on the stack (unless they are boxed or are part of a class), which can offer performance benefits for small types.</li>
  <li><strong>No Nullability</strong>: A struct cannot be null (unless it’s a nullable struct), which can prevent null reference exceptions.</li>
</ul>

<p>Example:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">struct</span> <span class="nc">OrderId</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="k">public</span> <span class="nf">OrderId</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="limitations">Limitations:</h3>

<ul>
  <li><strong>Manual Implementation of Equality</strong>: By default, structs use value equality, but this is based only on their public fields. If the struct contains reference types, or if you want to compare properties, you need to manually override <code class="language-plaintext highlighter-rouge">Equals()</code> and <code class="language-plaintext highlighter-rouge">GetHashCode()</code> methods.</li>
  <li><strong>Immutability is Manual</strong>: To make a struct immutable, you have to manually ensure none of the properties can be modified after initialization, as in your example.</li>
</ul>

<h2 id="records"><code class="language-plaintext highlighter-rouge">records</code></h2>

<h3 id="strengths-1">Strengths:</h3>

<ul>
  <li><strong>Immutability by Default</strong>: Records are immutable by default. Any attempt to change a property results in the creation of a new instance.</li>
  <li><strong>Value-Based Equality</strong>: Records provide value-based equality checks and useful <code class="language-plaintext highlighter-rouge">ToString</code> implementation out of the box. No need to manually override <code class="language-plaintext highlighter-rouge">Equals()</code> or <code class="language-plaintext highlighter-rouge">GetHashCode()</code>.</li>
</ul>

<p>Example:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">record</span> <span class="nc">OrderId</span><span class="p">(</span><span class="kt">int</span> <span class="n">Value</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="limitations-1">Limitations:</h3>

<ul>
  <li><strong>Performance</strong>: Records are reference types and are stored on the heap, which could lead to more garbage collection than a struct, depending on how they’re used.</li>
  <li><strong>Nullability</strong>: Records can be null, which means you need to guard against null reference exceptions.</li>
</ul>]]></content><author><name></name></author><category term="dotnet" /><summary type="html"><![CDATA[Comparison: C# structs vs records]]></summary></entry><entry><title type="html">Welcome</title><link href="https://blog.macrobert.com/welcome/2016/01/01/Welcome.html" rel="alternate" type="text/html" title="Welcome" /><published>2016-01-01T11:42:35+08:00</published><updated>2016-01-01T11:42:35+08:00</updated><id>https://blog.macrobert.com/welcome/2016/01/01/Welcome</id><content type="html" xml:base="https://blog.macrobert.com/welcome/2016/01/01/Welcome.html"><![CDATA[<p>Thanks for dropping by…</p>

<p>I’ve developed as a Software Professional, learning techniques from countless blogs like this one. Other developers have generously shared their wisdom and learning experiences to the benefit of a larger community. I’d like to do the same.</p>

<p>My focus is centered around cross platform .NET &amp; C++ development, associated languages and tools, plus a few other rambling observations and opinions.</p>

<p>The content is as much for sharing as well as for my own reference in future projects.
I hope you find it useful.</p>]]></content><author><name></name></author><category term="welcome" /><summary type="html"><![CDATA[Thanks for dropping by…]]></summary></entry></feed>