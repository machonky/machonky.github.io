<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://blog.macrobert.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.macrobert.com/" rel="alternate" type="text/html" /><updated>2023-10-26T14:57:03+08:00</updated><id>https://blog.macrobert.com/feed.xml</id><title type="html">macrobert.com</title><subtitle>Martin lives and works Internationally building really useful things.</subtitle><entry><title type="html">Strongly Typed Ids in Entity Framework Core (2/N)</title><link href="https://blog.macrobert.com/dotnet/strongly_typed_ids/efcore/2023/07/03/StronglyTypedIds_In_EF_Core.html" rel="alternate" type="text/html" title="Strongly Typed Ids in Entity Framework Core (2/N)" /><published>2023-07-03T12:00:00+08:00</published><updated>2023-07-03T12:00:00+08:00</updated><id>https://blog.macrobert.com/dotnet/strongly_typed_ids/efcore/2023/07/03/StronglyTypedIds_In_EF_Core</id><content type="html" xml:base="https://blog.macrobert.com/dotnet/strongly_typed_ids/efcore/2023/07/03/StronglyTypedIds_In_EF_Core.html"><![CDATA[<p>This article is a continuation of a <a href="/dotnet/strongly_typed_ids/2023/06/30/StronglyTypedIds.html">previous article</a> exploring the use of Strongly Typed Ids in .NET Entity Framework Core.</p>

<p>When developing applications with Entity Framework Core (EF Core), the usage of primary keys is a common practice, especially when defining your model entities. Often, these keys are simple types like <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, or <code class="language-plaintext highlighter-rouge">Guid</code>. However, there is another approach that can provide more clarity and safety to your code: Strongly Typed IDs.</p>

<p>A Strongly Typed ID is a wrapper around a simple value, such as an integer or a GUID, that gives it a specific meaning. For example, instead of having a method like <code class="language-plaintext highlighter-rouge">GetOrder(int orderId)</code>, you would have <code class="language-plaintext highlighter-rouge">GetOrder(OrderId orderId)</code>, where <code class="language-plaintext highlighter-rouge">OrderId</code> is a struct or a record that encapsulates the integer ID.</p>

<p>Strongly Typed IDs can bring several advantages to your code:</p>

<ul>
  <li><strong>Improved Readability</strong>: When you see a method signature like <code class="language-plaintext highlighter-rouge">GetOrder(OrderId orderId)</code>, it’s immediately clear what kind of ID the method expects.</li>
  <li><strong>Reduced Errors</strong>: With Strongly Typed IDs, you can’t accidentally pass an <code class="language-plaintext highlighter-rouge">int</code> intended for one kind of entity to a method that expects an <code class="language-plaintext highlighter-rouge">int</code> for a different kind of entity.</li>
  <li><strong>Better Abstraction</strong>: Each ID type can have its own methods and validation rules, encapsulating more behavior and making your code more Object-Oriented.</li>
</ul>

<h2 id="considerations-when-using-strongly-typed-ids-with-entity-framework-core">Considerations when using Strongly Typed IDs with Entity Framework Core</h2>

<p>When using EF Core, you need to consider how the framework will interact with your Strongly Typed IDs. Here are some things to keep in mind:</p>

<ul>
  <li><strong>Mapping to Database Columns</strong>: EF Core needs to know how to map your Strongly Typed ID to a database column. You’ll commonly use the Fluent API in your <code class="language-plaintext highlighter-rouge">DbContext</code> to configure this.</li>
</ul>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span>
    <span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">Id</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">HasConversion</span><span class="p">(</span>
        <span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span> 
        <span class="n">id</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">OrderId</span><span class="p">(</span><span class="n">id</span><span class="p">));</span>
</code></pre></div></div>

<ul>
  <li><strong>Equality Comparison</strong>: EF Core keeps track of entities based on their IDs. If not using a <code class="language-plaintext highlighter-rouge">record</code> type be sure your Strongly Typed ID implements <code class="language-plaintext highlighter-rouge">Equals</code> and <code class="language-plaintext highlighter-rouge">GetHashCode</code> correctly.</li>
  <li><strong>Performance</strong>: EF Core can track changes to entities based on their IDs. If your ID type has a heavy <code class="language-plaintext highlighter-rouge">Equals</code> or <code class="language-plaintext highlighter-rouge">GetHashCode</code> method, this could impact performance.</li>
  <li><strong>Maintainability</strong>: When adding a <code class="language-plaintext highlighter-rouge">HasConversion</code> implementation everywhere such an Id is used a codebase could become very tedious and hard to maintain.</li>
</ul>

<p>Note in the example above that a <code class="language-plaintext highlighter-rouge">HasConversion</code> implementation will need to be provided for every use of the <code class="language-plaintext highlighter-rouge">OrderId</code> throughout the various entity configurations. We’ll explore a better way for this integration.</p>

<p>If we choose to use Strongly Typed Ids we’d want to integrate the use of Strongly Typed Ids throughout our codebase so as to be as transparent and seamless as possible to minimise the development burden, while being aware of performance considerations.</p>

<p>We’d need:</p>
<ol>
  <li>every Strongly Typed Id to be discoverable. This is typically done via the use of an <code class="language-plaintext highlighter-rouge">Attribute</code> or interface declaration.</li>
  <li>the framework to discover each new Strongly Typed Id declaration based on the mechanism chosen above.</li>
  <li>to register a <strong>re-usable EF Core conversion</strong> so that the object can be persisted to-and-from a database wherever the type is encountered.</li>
</ol>

<p>We can explore how to do this with a non-trivial example.</p>

<h2 id="discoverability">Discoverability</h2>

<p>For our purposes we’ll use an interface approach to permit discovery via .NET Reflection of our Strongly Typed Id declarations.</p>

<p><strong>Example:</strong>
If we declare an interface <code class="language-plaintext highlighter-rouge">IStronglyTypedId</code> and express it generically we can use the interface as broadly as possible.</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">T</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>To keep things interesting we’ll make our Strongly Typed Ids use a <code class="language-plaintext highlighter-rouge">Ulid</code> value as the underlying value primitive. We’ll also use the ‘Value’ term as property used to extract the underlying primitive value.</p>

<p>Continuing our example therefore we can declare a <code class="language-plaintext highlighter-rouge">CompanyId</code> for use in a <code class="language-plaintext highlighter-rouge">Company</code> entity as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">record</span> <span class="nc">CompanyId</span><span class="p">(</span><span class="n">Ulid</span> <span class="n">Value</span><span class="p">)</span> <span class="p">:</span> <span class="n">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">&gt;;</span>
</code></pre></div></div>
<p>Given the declaration above we can now discover our Strongly Typed Id by scanning for implementations of <code class="language-plaintext highlighter-rouge">IStronglyTypedId&lt;Ulid&gt;</code>.</p>

<p>In a Domain Driven Design context, the <code class="language-plaintext highlighter-rouge">CompanyId</code> helps provide a unique identifier for a <code class="language-plaintext highlighter-rouge">Company </code> Entity so these classes would both be declared in a <code class="language-plaintext highlighter-rouge">Domain</code> project.</p>

<h2 id="framework-discovery-and-registration">Framework Discovery and Registration</h2>

<p>In a non-trivial application we might have 10’s of entity types (or more) and corresponding Id types. It becomes important to ensure that any method to discover this implementation does not rely on any form of manual registration owing to the risks of human error. Any <strong>failure to remember</strong> to modify a ‘registration-class’ will have undesirable consequences.</p>

<p>EF Core 7.0 introduces a new method to the <code class="language-plaintext highlighter-rouge">DBContext</code> which allows us to register new types with the framework:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">protected</span> <span class="k">internal</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">ConfigureConventions</span><span class="p">(</span><span class="n">ModelConfigurationBuilder</span> <span class="n">configurationBuilder</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div>
<p>This is known as <a href="https://aka.ms/efcore-docs-pre-convention">‘Pre-convention configuration’</a>.</p>

<p>By overriding the <code class="language-plaintext highlighter-rouge">ConfigureConventions</code> method we have an opportunity to get our application to discover our collection of Strongly Typed Ids.</p>

<p>For our implementation plan we would need to scan an assembly known to contain our Strongly Typed Ids and obtain the <code class="language-plaintext highlighter-rouge">System.Type</code> of each. We can then iterate through the collection registering each in turn.</p>

<p>To scan an assembly for an interface we might declare a re-usable scanner as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">AssemblyScanner</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">Assembly</span> <span class="n">targetAssembly</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">AssemblyScanner</span><span class="p">(</span><span class="n">Assembly</span> <span class="n">targetAssembly</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">targetAssembly</span> <span class="p">=</span> <span class="n">targetAssembly</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">...</span>

    <span class="k">public</span> <span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">&gt;</span> <span class="n">ScanForImplementations</span><span class="p">&lt;</span><span class="n">TInterface</span><span class="p">&gt;()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">&gt;();</span>
        <span class="kt">var</span> <span class="n">targetTypes</span> <span class="p">=</span> <span class="n">targetAssembly</span><span class="p">.</span><span class="nf">GetTypes</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">implementationTypes</span> <span class="p">=</span> <span class="n">targetTypes</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">t</span> <span class="p">=&gt;</span> <span class="k">typeof</span><span class="p">(</span><span class="n">TInterface</span><span class="p">).</span><span class="nf">IsAssignableFrom</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">t</span><span class="p">.</span><span class="n">IsInterface</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">t</span><span class="p">.</span><span class="n">IsAbstract</span><span class="p">);</span>

        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">type</span> <span class="k">in</span> <span class="n">implementationTypes</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
<p>In our <code class="language-plaintext highlighter-rouge">DBContext.ConfigureConventions</code> override we can employ the <code class="language-plaintext highlighter-rouge">AssemblyScanner</code> to search for our <code class="language-plaintext highlighter-rouge">IStronglyTypedId&lt;Ulid&gt;</code> implementations as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">ConfigureConventions</span><span class="p">(</span><span class="n">ModelConfigurationBuilder</span> <span class="n">configurationBuilder</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="kt">var</span> <span class="n">scanner</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AssemblyScanner</span><span class="p">(</span><span class="n">Domain</span><span class="p">.</span><span class="n">AssemblyReference</span><span class="p">.</span><span class="n">Assembly</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">typedIdTypes</span> <span class="p">=</span> <span class="n">scanner</span><span class="p">.</span><span class="n">ScanForImplementations</span><span class="p">&lt;</span><span class="n">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">&gt;&gt;();</span>
    <span class="nf">ConfigureStronglyTypedIds</span><span class="p">(</span><span class="n">typedIdTypes</span><span class="p">);</span>    
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">ConfigureStronglyTypedIds</span><span class="p">(</span><span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">&gt;</span> <span class="n">stronglyTypedIdTypes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">type</span> <span class="k">in</span> <span class="n">stronglyTypedIdTypes</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">configurationBuilder</span>
            <span class="p">.</span><span class="nf">Properties</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
            <span class="p">.</span><span class="nf">HaveMaxLength</span><span class="p">(</span><span class="n">EntityId</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
    <span class="p">}</span>    
<span class="p">}</span>

</code></pre></div></div>
<p>We know that <code class="language-plaintext highlighter-rouge">Ulid</code>’s can be expressed as text with 26 characters so <code class="language-plaintext highlighter-rouge">EntityId</code> is defined as:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">EntityId</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">Length</span> <span class="p">=</span> <span class="m">26</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So far our code seems trivial at this point… Except for one problem - we must define the conversion so our DB Provider can persist the data. The body of our loop should read something like:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">configurationBuilder</span>
            <span class="p">.</span><span class="nf">Properties</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
            <span class="p">.</span><span class="nf">HaveConversion</span><span class="p">(...</span><span class="n">What</span> <span class="n">goes</span> <span class="n">here</span><span class="p">?...)</span>
            <span class="p">.</span><span class="nf">HaveMaxLength</span><span class="p">(</span><span class="n">EntityId</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
</code></pre></div></div>
<p>So… what now?</p>

<h2 id="db-provider-value-conversion">DB Provider Value Conversion</h2>

<p>The <code class="language-plaintext highlighter-rouge">HaveConversion</code> FluentAPI demands that we supply some kind of <code class="language-plaintext highlighter-rouge">ValueConverter</code> derived class responsible for converting our Strongly Typed Id to-and-from a DB-Provider-Compatible type. We’re using a <code class="language-plaintext highlighter-rouge">Ulid</code> as our underlying value type which we’ll need to store as a string - at the time of writing <code class="language-plaintext highlighter-rouge">Ulid</code>’s are not widely supported as a Database data type.</p>

<p>We could write a <code class="language-plaintext highlighter-rouge">ValueConverter</code> for every <code class="language-plaintext highlighter-rouge">StronglyTypedId</code> that we define, but this would undermine the benefit of being able to declare a Strongly Typed Id in a single line.</p>

<p>To convert a <code class="language-plaintext highlighter-rouge">Ulid</code> to a <code class="language-plaintext highlighter-rouge">string</code> we can write a simple <code class="language-plaintext highlighter-rouge">ValueConverter</code> as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">Microsoft.EntityFrameworkCore.Storage.ValueConversion</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">UlidToStringConverter</span> <span class="p">:</span> <span class="n">ValueConverter</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">ConverterMappingHints</span> <span class="n">defaultHints</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ConverterMappingHints</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">EntityId</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>

    <span class="k">public</span> <span class="nf">UlidToStringConverter</span><span class="p">(</span><span class="n">ConverterMappingHints</span> <span class="n">mappingHints</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span>
                <span class="n">convertToProviderExpression</span><span class="p">:</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="nf">ToString</span><span class="p">(),</span>
                <span class="n">convertFromProviderExpression</span><span class="p">:</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">Ulid</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                <span class="n">mappingHints</span><span class="p">:</span> <span class="n">defaultHints</span><span class="p">.</span><span class="nf">With</span><span class="p">(</span><span class="n">mappingHints</span><span class="p">))</span>
    <span class="p">{}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This is not of much use to us, as it is for our underlying type, not the Strongly Typed Id.</p>

<p>However, based on the example above we could conservatively estimate that we have 10 lines of code per Strongly Typed Id of overhead. So our 40 lines of Strongly Typed Id code now has 400 lines of overhead-code to maintain… Excluding unit-test code. <strong>Not Ideal</strong>. We need to avoid this at all costs as this approach scales badly.</p>

<p>We need our framework to <strong>‘automagically’</strong> declare a <code class="language-plaintext highlighter-rouge">ValueConverter</code> for us, as each Strongly Typed Id is discovered.</p>

<p>If we explore further we can we can exploit the power of .NET Generics to create a <code class="language-plaintext highlighter-rouge">ValueConverter</code> to convert to-and-from our Strong Type to a <code class="language-plaintext highlighter-rouge">Ulid</code> as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">StronglyTypedIdToUlidConverter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">ValueConverter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ulid</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">StronglyTypedIdToUlidConverter</span><span class="p">(</span><span class="n">ConverterMappingHints</span><span class="p">?</span> <span class="n">mappingHints</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span>
            <span class="n">convertToProviderExpression</span><span class="p">:</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">Value</span><span class="p">,</span>
            <span class="n">convertFromProviderExpression</span><span class="p">:</span> <span class="n">x</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="n">Activator</span><span class="p">.</span><span class="nf">CreateInstance</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="k">new</span> <span class="kt">object</span><span class="p">[]</span> <span class="p">{</span> <span class="n">x</span> <span class="p">})!,</span>
            <span class="n">mappingHints</span><span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We’re aiming at producing a <code class="language-plaintext highlighter-rouge">StronglyTypedIdToStringConverter</code> that takes a StronglyTypedId generic parameter to convert back and forth between Strongly Typed Ids and strings.</p>

<p>At this point we have x2 implementations that we need to link together. In pseudocode:</p>
<ul>
  <li>Our <code class="language-plaintext highlighter-rouge">convertToProviderExpression</code> must implement <code class="language-plaintext highlighter-rouge">StrongTypeId =&gt; Ulid =&gt; string</code>.</li>
  <li>Our <code class="language-plaintext highlighter-rouge">convertFromProviderExpression</code> must implement <code class="language-plaintext highlighter-rouge">string =&gt; Ulid.Parse(...) =&gt; StrongTypeId</code>.</li>
</ul>

<p>If we express our observations above generically:</p>
<ul>
  <li>We see the <code class="language-plaintext highlighter-rouge">ModelType</code> is our <code class="language-plaintext highlighter-rouge">StrongTypeId</code>.</li>
  <li>We have a <code class="language-plaintext highlighter-rouge">Ulid</code> for an intermediate or <code class="language-plaintext highlighter-rouge">MiddleType</code></li>
  <li>Lastly we have a <code class="language-plaintext highlighter-rouge">string</code> as our <code class="language-plaintext highlighter-rouge">ProviderType</code>.</li>
</ul>

<p>Some extensive spelunking through the EF Core sources revealed a potentially useful <code class="language-plaintext highlighter-rouge">ValueConverter</code> class that allows us to link our implementations above to create what we need:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Microsoft.EntityFrameworkCore.Storage.ValueConversion.Internal</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">CompositeValueConverter</span><span class="p">&lt;</span><span class="n">TModel</span><span class="p">,</span> <span class="n">TMiddle</span><span class="p">,</span> <span class="n">TProvider</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">ValueConverter</span><span class="p">&lt;</span><span class="n">TModel</span><span class="p">,</span> <span class="n">TProvider</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">CompositeValueConverter</span><span class="p">(</span><span class="n">ValueConverter</span> <span class="n">converter1</span><span class="p">,</span> <span class="n">ValueConverter</span> <span class="n">converter2</span><span class="p">,</span> <span class="n">ConverterMappingHints</span><span class="p">?</span> <span class="n">mappingHints</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="nf">Compose</span><span class="p">((</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TModel</span><span class="p">,</span> <span class="n">TMiddle</span><span class="p">&gt;&gt;)</span><span class="n">converter1</span><span class="p">.</span><span class="n">ConvertToProviderExpression</span><span class="p">,</span> <span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TMiddle</span><span class="p">,</span> <span class="n">TProvider</span><span class="p">&gt;&gt;)</span><span class="n">converter2</span><span class="p">.</span><span class="n">ConvertToProviderExpression</span><span class="p">),</span> <span class="nf">Compose</span><span class="p">((</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TProvider</span><span class="p">,</span> <span class="n">TMiddle</span><span class="p">&gt;&gt;)</span><span class="n">converter2</span><span class="p">.</span><span class="n">ConvertFromProviderExpression</span><span class="p">,</span> <span class="p">(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TMiddle</span><span class="p">,</span> <span class="n">TModel</span><span class="p">&gt;&gt;)</span><span class="n">converter1</span><span class="p">.</span><span class="n">ConvertFromProviderExpression</span><span class="p">),</span> <span class="n">mappingHints</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="k">private</span> <span class="k">static</span> <span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;&gt;</span> <span class="n">Compose</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">,</span> <span class="n">TMiddle</span><span class="p">&gt;&gt;</span> <span class="n">upper</span><span class="p">,</span> <span class="n">Expression</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TMiddle</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;&gt;</span> <span class="n">lower</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Expression</span><span class="p">.</span><span class="n">Lambda</span><span class="p">&lt;</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;&gt;(</span><span class="n">ReplacingExpressionVisitor</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="n">lower</span><span class="p">.</span><span class="n">Parameters</span><span class="p">.</span><span class="nf">Single</span><span class="p">(),</span> <span class="n">upper</span><span class="p">.</span><span class="n">Body</span><span class="p">,</span> <span class="n">lower</span><span class="p">.</span><span class="n">Body</span><span class="p">),</span> <span class="k">new</span> <span class="n">ParameterExpression</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">{</span> <span class="n">upper</span><span class="p">.</span><span class="n">Parameters</span><span class="p">.</span><span class="nf">Single</span><span class="p">()</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>For the the <code class="language-plaintext highlighter-rouge">CompositeValueConverter</code> snippet above</p>
<ul>
  <li>our <code class="language-plaintext highlighter-rouge">ModelType</code> maps neatly to the <code class="language-plaintext highlighter-rouge">TModel</code> generic parameter.</li>
  <li>our <code class="language-plaintext highlighter-rouge">MiddleType</code> maps to the <code class="language-plaintext highlighter-rouge">TMiddle</code> parameter</li>
  <li>lastly our <code class="language-plaintext highlighter-rouge">ProviderType</code> maps to the <code class="language-plaintext highlighter-rouge">TProvider</code> generic parameter.</li>
</ul>

<p>It’s pretty clear that by placing this class in an <strong>Internal</strong> namespace the EF Core authors don’t intend this to be part of the public EF Core API. However it provides a perfect solution to our problem.</p>

<p>We can ‘borrow’ the implementation in our code and re-use the <code class="language-plaintext highlighter-rouge">UlidToStringConverter</code> and  <code class="language-plaintext highlighter-rouge">StronglyTypedIdToUlidConverter&lt;T&gt;</code> implementations and <strong>compose</strong> our generic <code class="language-plaintext highlighter-rouge">ValueConverter</code> as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">StronglyTypedIdToStringConverter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> 
    <span class="p">:</span> <span class="n">CompositeValueConverter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Ulid</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">StronglyTypedIdToStringConverter</span><span class="p">()</span>
        <span class="p">:</span> <span class="k">base</span><span class="p">(</span>
            <span class="k">new</span> <span class="n">StronglyTypedIdToUlidConverter</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(),</span> 
            <span class="k">new</span> <span class="nf">UlidToStringConverter</span><span class="p">())</span>
    <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’re now much closer to being able to <strong>automagically</strong> create an implementation of a value converter, as we can synthesize a concrete <code class="language-plaintext highlighter-rouge">ValueConverter</code> type by filling in the generic parameter via the Reflection API (as shown):</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">concreteValueConverterType</span> <span class="p">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">StronglyTypedIdToStringConverter</span><span class="p">&lt;&gt;).</span><span class="nf">MakeGenericType</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
</code></pre></div></div>

<p>Given our <code class="language-plaintext highlighter-rouge">foreach - stronglyTypedIdTypes</code> loop above, we can now automatically register the <code class="language-plaintext highlighter-rouge">ValueConverter</code> for all StronglyTypedIds in our application, including DB Type Mapping. Our <code class="language-plaintext highlighter-rouge">DBContext.ConfigureConventions</code> loop code becomes:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">ConfigureConventions</span><span class="p">(</span><span class="n">ModelConfigurationBuilder</span> <span class="n">configurationBuilder</span><span class="p">)</span> 
<span class="p">{</span> 
    <span class="kt">var</span> <span class="n">scanner</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AssemblyScanner</span><span class="p">(</span><span class="n">Domain</span><span class="p">.</span><span class="n">AssemblyReference</span><span class="p">.</span><span class="n">Assembly</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">typedIdTypes</span> <span class="p">=</span> <span class="n">scanner</span><span class="p">.</span><span class="n">ScanForImplementations</span><span class="p">&lt;</span><span class="n">IStronglyTypedId</span><span class="p">&lt;</span><span class="n">Ulid</span><span class="p">&gt;&gt;();</span>
    <span class="nf">ConfigureStronglyTypedIds</span><span class="p">(</span><span class="n">typedIdTypes</span><span class="p">);</span>    
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">ConfigureStronglyTypedIds</span><span class="p">(</span><span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="n">Type</span><span class="p">&gt;</span> <span class="n">stronglyTypedIdTypes</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">type</span> <span class="k">in</span> <span class="n">stronglyTypedIdTypes</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">configurationBuilder</span>
            <span class="p">.</span><span class="nf">Properties</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
            <span class="p">.</span><span class="nf">HaveConversion</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">StronglyTypedIdToStringConverter</span><span class="p">&lt;&gt;).</span><span class="nf">MakeGenericType</span><span class="p">(</span><span class="n">type</span><span class="p">))</span>
            <span class="p">.</span><span class="nf">HaveMaxLength</span><span class="p">(</span><span class="n">EntityId</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
    <span class="p">}</span>    
<span class="p">}</span>
</code></pre></div></div>

<p>Returning to our original example for an <code class="language-plaintext highlighter-rouge">Order</code> that might use an <code class="language-plaintext highlighter-rouge">OrderId</code> for it’s Id property… 
The Configuration code becomes:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span>
    <span class="p">.</span><span class="n">Entity</span><span class="p">&lt;</span><span class="n">Order</span><span class="p">&gt;()</span>
    <span class="p">.</span><span class="nf">Property</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">Id</span><span class="p">);</span>
</code></pre></div></div>
<p>The EF Core framework is now fully aware of what the <code class="language-plaintext highlighter-rouge">OrderId</code> is and how to interact with the database, so the <code class="language-plaintext highlighter-rouge">HaveConversion</code> code is no longer required as a generic <code class="language-plaintext highlighter-rouge">ValueConverter</code> has already been registered.</p>

<h2 id="summary">Summary</h2>
<p>I’ve demonstrated how we can <strong>automagically</strong> integrate the use of Strongly Typed Ids throughout an EF Core based application.</p>

<p>This includes</p>
<ul>
  <li>the discovery of Strongly Typed Ids throughout an assembly,</li>
  <li>the registration of the types with the EF Core framework</li>
  <li>as well as the automatic implementation of conversions to suit a DB Provider.</li>
</ul>

<p>Casting aside performance considerations, these three implementation details ensure a trouble free and scalable solution to the use of Strongly Typed Ids within an EF Core application.</p>]]></content><author><name></name></author><category term="dotnet" /><category term="strongly_typed_ids" /><category term="efcore" /><summary type="html"><![CDATA[This article is a continuation of a previous article exploring the use of Strongly Typed Ids in .NET Entity Framework Core.]]></summary></entry><entry><title type="html">Strongly Typed Ids (1/N)</title><link href="https://blog.macrobert.com/dotnet/strongly_typed_ids/2023/06/30/StronglyTypedIds.html" rel="alternate" type="text/html" title="Strongly Typed Ids (1/N)" /><published>2023-06-30T12:00:00+08:00</published><updated>2023-06-30T12:00:00+08:00</updated><id>https://blog.macrobert.com/dotnet/strongly_typed_ids/2023/06/30/StronglyTypedIds</id><content type="html" xml:base="https://blog.macrobert.com/dotnet/strongly_typed_ids/2023/06/30/StronglyTypedIds.html"><![CDATA[<p>While studying Domain Driven Design and software architecture, I’ve seen strong advocacy for the use of Strongly-Typed-Ids instead of the traditional use of strings, guids and integers with the aim of preventing ‘Primitive Obsession’ and the ensuing errors associated with this behaviour.</p>

<p>‘Primitive Obsession’ is a term coined by <strong><em>Martin Fowler</em></strong>, a prominent software developer and author. The term is used in software development to describe a scenario where developers use primitive data types to represent domain ideas.</p>

<p><strong><em>Eric Evans</em></strong>, the author of the book <strong><em>“Domain-Driven Design: Tackling Complexity in the Heart of Software”</em></strong>,  is one significant figure in the Domain-Driven Design (DDD) community, which often advocates for practices like strongly-typed IDs. While Evans himself may not explicitly advocate for strongly-typed IDs, the principles he outlines in his book align well with the concept.</p>

<p>Many advocates of statically-typed languages such as C#, Java, or TypeScript also tend to favor strongly-typed IDs. These languages, by their nature, encourage the use of explicit types to improve code clarity and safety.</p>

<p>In the context of EF Core applications, ‘Primitive Obsession’ often refers to using primitive types such as <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">string</code>, or <code class="language-plaintext highlighter-rouge">Guid</code> to represent entity IDs, rather than creating a separate, more specific type. For instance, rather than creating a CustomerId type for customer IDs, a developer might just use an <code class="language-plaintext highlighter-rouge">int</code>. This can lead to confusion as these IDs are passed around the application, as it’s unclear what type of entity the ID refers to.</p>

<p>While using primitive types can be quicker and simpler in the short term, it can lead to problems in the long term, including:</p>

<ul>
  <li><strong>Lack of clarity</strong>: Without a specific type, it’s not immediately clear what an ID refers to. This can make the code harder to understand and maintain.</li>
  <li><strong>Type safety issues</strong>: If you’re using primitive types for IDs, it’s easy to accidentally pass an ID of one type to a method that expects an ID of a different type. The compiler won’t catch this error, and it could lead to bugs that are hard to track down.</li>
  <li><strong>Missed opportunities for encapsulation</strong>: By using a specific type, you can encapsulate logic related to the ID inside that type. For instance, if there are specific rules around what values an ID can have, those rules can be enforced in the ID type itself.</li>
</ul>

<p>To counter this ‘Primitive Obsession’ one should use ‘Domain Primitives’ or ‘Value Objects’. These are small classes that encapsulate a simple domain concept. For example, instead of using an <code class="language-plaintext highlighter-rouge">int</code> for a customer ID, you could create a formal <code class="language-plaintext highlighter-rouge">CustomerId</code> class. This makes the code more self-documenting and helps prevent errors. However, it can increase the complexity of the codebase and requires careful design to ensure the classes are correctly implemented.</p>

<h2 id="lets-look-a-little-closer">Lets look a little closer…</h2>

<p>When building software applications, it’s common to use identifiers (IDs) to uniquely distinguish entities. This is especially true in the realm of databases where IDs are used as primary keys. In .NET’s Entity Framework Core, the default type for these identifiers is often an integer or a GUID. However, there’s a growing trend towards using Strongly-Typed IDs, an approach that has its own set of advantages and limitations.</p>

<h2 id="what-are-strongly-typed-ids">What are Strongly-Typed IDs?</h2>

<p>Traditionally, IDs in Entity Framework Core are represented as simple primitives, like int, long, or Guid. However, these types don’t provide any context or meaning about what they represent. They are just raw values.</p>

<p>Strongly-Typed IDs, on the other hand, wrap these raw values in a more meaningful type. For instance, instead of having an integer represent an OrderID, a new type <code class="language-plaintext highlighter-rouge">OrderId</code> is created. This new type can help to avoid errors and provide clarity about what the ID represents.</p>

<h3 id="example">Example</h3>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">struct</span> <span class="nc">OrderId</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="k">public</span> <span class="nf">OrderId</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In the example above the class name helps express the intent of the class, while being declared as a <code class="language-plaintext highlighter-rouge">struct</code> ensures that equality comparisons are based on their values. If a contained property were to be of a reference type however it would be necessary to override the <code class="language-plaintext highlighter-rouge">Equals</code> method (and <code class="language-plaintext highlighter-rouge">GetHashCode</code> method) in the struct to ensure a proper value comparison.</p>

<p>As of C# 9.0 as part of .NET 5, (released in November 2020), the newer <code class="language-plaintext highlighter-rouge">record</code> type permits a more compact expression of such types as shown:</p>
<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">record</span> <span class="nc">OrderId</span><span class="p">(</span><span class="kt">int</span> <span class="n">Value</span><span class="p">);</span>
</code></pre></div></div>
<p>The ease of declaration of such types makes it very tempting for use in new projects or retrofitting to older ones.</p>

<p>This being said, it would be wise to identify the full cost of the use of such types in any major project.</p>]]></content><author><name></name></author><category term="dotnet" /><category term="strongly_typed_ids" /><summary type="html"><![CDATA[While studying Domain Driven Design and software architecture, I’ve seen strong advocacy for the use of Strongly-Typed-Ids instead of the traditional use of strings, guids and integers with the aim of preventing ‘Primitive Obsession’ and the ensuing errors associated with this behaviour.]]></summary></entry><entry><title type="html">Comparison: C# `structs` vs `records`</title><link href="https://blog.macrobert.com/dotnet/2023/06/29/structs_vs_records.html" rel="alternate" type="text/html" title="Comparison: C# `structs` vs `records`" /><published>2023-06-29T12:00:00+08:00</published><updated>2023-06-29T12:00:00+08:00</updated><id>https://blog.macrobert.com/dotnet/2023/06/29/structs_vs_records</id><content type="html" xml:base="https://blog.macrobert.com/dotnet/2023/06/29/structs_vs_records.html"><![CDATA[<h1 id="comparison-c-structs-vs-records">Comparison: C# <code class="language-plaintext highlighter-rouge">structs</code> vs <code class="language-plaintext highlighter-rouge">records</code></h1>

<h2 id="structs"><code class="language-plaintext highlighter-rouge">structs</code></h2>

<h3 id="strengths">Strengths:</h3>

<ul>
  <li><strong>Performance</strong>: As value types, structs are stored on the stack (unless they are boxed or are part of a class), which can offer performance benefits for small types.</li>
  <li><strong>No Nullability</strong>: A struct cannot be null (unless it’s a nullable struct), which can prevent null reference exceptions.</li>
</ul>

<p>Example:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">struct</span> <span class="nc">OrderId</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    
    <span class="k">public</span> <span class="nf">OrderId</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Value</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="limitations">Limitations:</h3>

<ul>
  <li><strong>Manual Implementation of Equality</strong>: By default, structs use value equality, but this is based only on their public fields. If the struct contains reference types, or if you want to compare properties, you need to manually override <code class="language-plaintext highlighter-rouge">Equals()</code> and <code class="language-plaintext highlighter-rouge">GetHashCode()</code> methods.</li>
  <li><strong>Immutability is Manual</strong>: To make a struct immutable, you have to manually ensure none of the properties can be modified after initialization, as in your example.</li>
</ul>

<h2 id="records"><code class="language-plaintext highlighter-rouge">records</code></h2>

<h3 id="strengths-1">Strengths:</h3>

<ul>
  <li><strong>Immutability by Default</strong>: Records are immutable by default. Any attempt to change a property results in the creation of a new instance.</li>
  <li><strong>Value-Based Equality</strong>: Records provide value-based equality checks and useful <code class="language-plaintext highlighter-rouge">ToString</code> implementation out of the box. No need to manually override <code class="language-plaintext highlighter-rouge">Equals()</code> or <code class="language-plaintext highlighter-rouge">GetHashCode()</code>.</li>
</ul>

<p>Example:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">record</span> <span class="nc">OrderId</span><span class="p">(</span><span class="kt">int</span> <span class="n">Value</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="limitations-1">Limitations:</h3>

<ul>
  <li><strong>Performance</strong>: Records are reference types and are stored on the heap, which could lead to more garbage collection than a struct, depending on how they’re used.</li>
  <li><strong>Nullability</strong>: Records can be null, which means you need to guard against null reference exceptions.</li>
</ul>]]></content><author><name></name></author><category term="dotnet" /><summary type="html"><![CDATA[Comparison: C# structs vs records]]></summary></entry><entry><title type="html">Welcome</title><link href="https://blog.macrobert.com/welcome/2016/01/01/Welcome.html" rel="alternate" type="text/html" title="Welcome" /><published>2016-01-01T11:42:35+08:00</published><updated>2016-01-01T11:42:35+08:00</updated><id>https://blog.macrobert.com/welcome/2016/01/01/Welcome</id><content type="html" xml:base="https://blog.macrobert.com/welcome/2016/01/01/Welcome.html"><![CDATA[<p>Thanks for dropping by…</p>

<p>I’ve developed as a Software Professional, learning techniques from countless blogs like this one. Other developers have generously shared their wisdom and learning experiences to the benefit of a larger community. I’d like to do the same.</p>

<p>My focus is centered around cross platform .NET &amp; C++ development, associated languages and tools, plus a few other rambling observations and opinions.</p>

<p>The content is as much for sharing as well as for my own reference in future projects.
I hope you find it useful.</p>]]></content><author><name></name></author><category term="welcome" /><summary type="html"><![CDATA[Thanks for dropping by…]]></summary></entry></feed>